#!/bin/bash -e
# Run through the entire decoding process.

# FIXME: Detect PCM deemphasis automatically
# FIXME: Detect CX decoding automatically
# FIXME: Do this with short PAL/NTSC CAV/CLV examples with -fsanitize={undefined,address}...
# FIXME: Clean up intermediate files (.doc, .map) once complete

usage () {
	echo >&2 "Usage: $0 [-AcdDmnp] [-f DECODER] LDS-FILE [OUTPUT-BASE]"
	exit 1
}

analogue=true
digital=true
dropouts=false
deemph=()
decoder=
discmap=false
dryrun=false
standard=ntsc
while getopts "Acdf:Dmnp" c; do
	case "$c" in
	A)
		analogue=false
		;;
	c)
		dropouts=true
		;;
	d)
		deemph=(deemph)
		;;
	f)
		decoder="$OPTARG"
		;;
	D)
		digital=false
		;;
	m)
		discmap=true
		;;
	n)
		dryrun=true
		;;
	p)
		standard=pal
		;;
	\?)
		usage
		;;
	esac
done
shift $(expr $OPTIND - 1)

if [ "$#" = 1 ]; then
	infile="$1"
	out=$(dirname "$1")/out/$(basename "$1" .lds)
elif [ "$#" = 2 ]; then
	infile="$1"
	out="$2"
else
	usage
fi

if $analogue && $digital && [ "$standard" = pal ]; then
	echo >&2 "PAL can't have both analogue and digital audio"
	exit 1
fi

action () {
	if $dryrun; then
		echo >&2 "Would do:" "$@"
	else
		echo >&2 ">>>" "$@"
		"$@"
	fi
}

if [ ! -f "$out.tbc" ]; then
	action ld-decode.py "--$standard" "$infile" "$out"
fi

if [ ! -f "$out.tbc.json.orig" ]; then
	# This doesn't produce a new file.
	action cp "$out.tbc.json" "$out.tbc.json.orig_"
	action ld-process-vbi -n "$out.tbc"
	action mv "$out.tbc.json.orig_" "$out.tbc.json.orig"
fi

if $digital && [ ! -f "$out.digital.pcm" ]; then
	action ld-process-efm --noninteractive "$out".efm "$out".digital.pcm
fi

if $digital && [ ! -f "$out.digital.flac" ]; then
	action sox \
		-t raw -e signed -b 16 -r 44100 -c 2 "$out".digital.pcm \
		"$out".digital.flac \
		"${deemph[@]}" \
		stats
fi

if $analogue && [ ! -f "$out.analogue.flac" ]; then
	action sox \
		-t raw -e signed -b 16 -r 48000 -c 2 "$out".pcm \
		"$out".analogue.flac \
		stats
fi

prevtbc="$out".tbc

if $dropouts; then
	if [ ! -f "$out.doc" ]; then
		action ld-dropout-correct --overcorrect "$prevtbc" "$out".doc
	fi
	prevtbc="$out".doc
fi

if $discmap; then
	if [ ! -f "$out.map" ]; then
		action ld-discmap "$prevtbc" "$out".map
	fi
	prevtbc="$out".map
fi

if [ ! -f "$out.mkv" ]; then
	chargs=()
	if [ -n "$decoder" ]; then
		chargs+=(-f "$decoder")
		# XXX For now...
		if [ "$decoder" = transform3d ]; then
			chargs+=(--transform-mode level)
		fi
	fi
	chargs+=("$prevtbc")

	ffargs=(-f rawvideo -pix_fmt rgb48)
	if [ "$standard" = pal ]; then
		ffargs+=(-r 25 -s 928x576)
	else
		ffargs+=(-r 30000/1001 -s 760x488)
	fi
	ffargs+=(-i -)
	streams=0
	if $digital; then
		ffargs+=(-i "$out".digital.flac)
		digstream=$streams
		streams=$(($streams + 1))
	fi
	if $analogue; then
		ffargs+=(-i "$out".analogue.flac)
		anastream=$streams
		streams=$(($streams + 1))
	fi
	for i in $(seq 0 $streams); do
		ffargs+=(-map $i:0)
	done
	# Use yuvj444p for full range and no chroma subsampling.
	ffargs+=( \
		-pix_fmt yuvj444p \
		-filter:v setfield=tff \
		-codec:v libx264 -crf 16 -flags +ildct+ilme -aspect 4:3 \
	)
	if $digital; then
		ffargs+=(-codec:a:$digstream copy)
	fi
	if $analogue; then
		ffargs+=(-codec:a:$anastream copy)
	fi
	ffargs+=(-y "$out".mkv)

	action ld-chroma-decoder "${chargs[@]}" | \
	action ffmpeg "${ffargs[@]}"
fi
