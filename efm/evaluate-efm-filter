#!/usr/bin/python3
"""
Evaluate EFM filters by running test decodes and looking at the statistics
ld-process-efm produces.
"""

import concurrent.futures
import numpy
import os
import random
import re
import scipy.signal
import scipy.stats
import subprocess
import sys
import tempfile

import commpy_filters

SAMPLE_RATE = 40e6

class Candidate:
    """A filter design to be evaluated."""

    def __init__(self, params):
        self.params = params

        self.futures = {}
        self.results = {}
        self.score = None
        self.target = None

    def __str__(self):
        return "Candidate(%s)" % str(self.params)

class Testcase:
    """An RF sample that can be decoded."""

    def __init__(self, filename, length):
        self.filename = filename
        self.length = length

        with open(filename, "rb") as f:
            self.data = numpy.fromfile(f, numpy.int16, int(length))

    def __str__(self):
        return self.name()

    def name(self):
        return "Testcase(%s, %d)" % (self.filename, int(self.length))

def evaluate(candidate, testcase):
    """Evaluate candidate against testcase: filter testcase's data using the
    candidate filter, then feed it through ld-ldstoefm and ld-process-efm, and
    parse ld-process-efm's log output for statistics.

    Returns a dictionary of statistics."""

    params = candidate.params
    filtered = testcase.data

    # Apply filters (based on computeefmfilter from ldddecode_core)

    # Highpass
    b, a = scipy.signal.butter(params["HP_N"], [params["HP_f"]], btype="high", fs=SAMPLE_RATE)
    filtered = scipy.signal.lfilter(b, a, filtered)

    # Lowpass
    b, a = scipy.signal.ellip(params["LP_N"], params["LP_rp"], params["LP_rs"], [params["LP_f"]], fs=SAMPLE_RATE)
    # This gets applied twice in FFT form
    filtered = scipy.signal.lfilter(b, a, filtered)
    filtered = scipy.signal.lfilter(b, a, filtered)

    # Shaping
    ts, hs = commpy_filters.rcosfilter(params["S_N"], params["S_alpha"], params["S_Ts"], SAMPLE_RATE)
    filtered = scipy.signal.lfilter(hs, [1.0], filtered)

    if False:
        # Dump to a file for inspection
        with open("/var/tmp/out.s16", "wb") as f:
            filtered.astype(numpy.int16).tofile(f)

    with tempfile.TemporaryDirectory(dir="/var/tmp") as tempdir:
        # Run the PLL
        efm_filename = os.path.join(tempdir, "eval.efm")
        p = subprocess.Popen(["ld-ldstoefm", efm_filename], stdin=subprocess.PIPE, stderr=subprocess.DEVNULL)
        p.stdin.write(filtered.astype(numpy.int16).tobytes())
        p.stdin.close()
        rc = p.wait()
        assert rc == 0

        # XXX do this if rc != 0
        # XXX ld-process-efm pops up a dialog if the input file is empty! Write a dummy file...
        if os.stat(efm_filename).st_size == 0:
            with open(efm_filename, "wb") as f:
                f.write(bytes([3]))

        # Run ld-process-efm and collect statistics
        p = subprocess.Popen(["ld-process-efm", "-n", efm_filename, "/dev/null"], stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
        section = None
        counts = {}
        for line in p.stderr.readlines():
            line = line.decode("UTF-8").rstrip()
            if not line.startswith("Info: "):
                continue
            line = line[6:].lstrip()

            if line.endswith(":"):
                section = line[:-1]
                continue

            m = re.match(r'(.*): (\d+)', line)
            if m is not None:
                name = m.group(1)
                count = int(m.group(2))

                if section == "EFM to F3 Frames":
                    if name == "Valid syncs":
                        counts["syncs"] = count
                    elif name == "Valid EFM symbols":
                        counts["symbols"] = count
                    elif name == "Valid frames":
                        counts["frames"] = count
                elif section == "F3 Frame to F2 Frame decode":
                    if name == "Total input F3 Frames":
                        counts["f3"] = count
                    elif name == "Total output F2 Frames":
                        counts["f2"] = count
                elif section == "F2 Frames to F1 Frames":
                    if name == "Valid frames":
                        counts["f1"] = count
        p.stderr.close()
        rc = p.wait()
        assert rc == 0

    # Make sure we saw all the stats we expect
    assert len(counts) == 6

    return counts

# To produce a testcase, do something like:
# XXX Better to load only one at a time into memory?
testdir = "/d/extra/laserdisc/audio/"
testcases = [
    Testcase(testdir + "domesday.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "fawlty.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "grateful.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "spinaltap.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "squibnocket.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "thx.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "wargames.s16", 1 * SAMPLE_RATE),
    Testcase(testdir + "wight.s16", 1 * SAMPLE_RATE),
    ]

executor = concurrent.futures.ThreadPoolExecutor(max_workers=os.cpu_count())

def submit_eval(cand):
    """Start evaluating cand against all the testcases."""

    for testcase in testcases:
        cand.futures[testcase.name()] = executor.submit(evaluate, cand, testcase)

def finish_eval(cands):
    """Wait for evaluation to finish for a list of candidates, and compute
    their fitnesses."""

    print("Evaluating", len(cands), end="", flush=True)

    winners = 0
    for i, cand in enumerate(cands):
        # Collect any outstanding results
        for name, future in cand.futures.items():
            cand.results[name] = future.result()
        cand.futures = {}

        # Compute fitness
        cand.score = 0
        for testcase in testcases:
            result = cand.results[testcase.name()]
            for name, value in result.items():
                weight = 1
                # More value for correctly-decoded frames
                if name in ("frames", "f3", "f2", "f1"):
                    weight = 100
                cand.score += value * weight

        print(".", end="", flush=True)
        remaining = len(cands) - i
        if (remaining % 20) == 0:
            print(remaining, end="", flush=True)

    print()

population = []

# lddecode_core's stock config, for comparison
cand = Candidate({
    "HP_N": 1,
    "HP_f": 0.4e6,
    "LP_N": 4,
    "LP_rp": 1.825,
    "LP_rs": 26,
    "LP_f": 2.0e6,
    "S_N": 221,
    "S_alpha": 0.5,
    "S_Ts": 1/4321800,
    })
population.append(cand)
submit_eval(cand)

for hp_f in range(400, 550, 25): # range(100, 800, 50):
    for lp_rp in range(1400, 2000, 50): # range(1600, 2000, 50):
        for lp_rs in range(22, 30, 2):
            for lp_f in [2100]: # range(1800, 2200, 100):
                cand = Candidate({
                    "HP_N": 1,
                    "HP_f": 0.001e6 * hp_f, # 0.4e6,
                    "LP_N": 4,
                    "LP_rp": 0.001 * lp_rp, # 1.825,
                    "LP_rs": 1.0 * lp_rs, # 26,
                    "LP_f": 0.001e6 * lp_f, # 2.0e6,
                    "S_N": 221,
                    "S_alpha": 0.5,
                    "S_Ts": 1/4321800,
                    })
                population.append(cand)
                submit_eval(cand)

finish_eval(population)

# Sort best first
population.sort(key=lambda cand: -cand.score)

# Show the leaderboard
print()
print("%-20s %s" % ("Score", "Candidate"))
for cand in population:
    print("%-20d" % cand.score, str(cand))
    for testcase in testcases:
        print("    %-20s %s" % (os.path.basename(testcase.filename), str(cand.results[testcase.name()])))
scores = [cand.score for cand in population]
print("Scores:", " ".join([str(score) for score in scores]))
print("Score stats:", scipy.stats.describe(scores))
print()
